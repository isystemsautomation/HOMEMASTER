modbus_controller:
  - id: ${rgb_id}
    address: ${rgb_address}
    modbus_id: modbus_bus
    update_interval: 1s
    command_throttle: 0ms

# ===================== Discrete Inputs (FC02) =====================
binary_sensor:
  # --- Digital Inputs DI1..DI2 ---
  - platform: modbus_controller
    modbus_controller_id: ${rgb_id}
    name: "${rgb_prefix} DI1"
    address: 1
    register_type: discrete_input

  - platform: modbus_controller
    modbus_controller_id: ${rgb_id}
    name: "${rgb_prefix} DI2"
    address: 2
    register_type: discrete_input

  # --- Relay1 logical state (after cfg/invert) ---
  - platform: modbus_controller
    modbus_controller_id: ${rgb_id}
    name: "${rgb_prefix} Relay1 State"
    address: 60
    register_type: discrete_input

  # --- LED logical states ---
  - platform: modbus_controller
    modbus_controller_id: ${rgb_id}
    name: "${rgb_prefix} LED1"
    address: 90
    register_type: discrete_input

  - platform: modbus_controller
    modbus_controller_id: ${rgb_id}
    name: "${rgb_prefix} LED2"
    address: 91
    register_type: discrete_input

# ===================== Coils (FC01/05) â€” momentary pulses =====================
# Relay1 ON: 200 | Relay1 OFF: 210
# DI1..2 ENABLE: 300..301 | DI1..2 DISABLE: 320..321
switch:
  # --- Relay ON/OFF pulses (auto-off in 200ms) ---
  - platform: modbus_controller
    id: ${rgb_id}_rly1_on
    modbus_controller_id: ${rgb_id}
    name: "${rgb_prefix} Relay1 ON (Pulse)"
    address: 200
    register_type: coil
    on_turn_on:
      - delay: 200ms
      - switch.turn_off: ${rgb_id}_rly1_on

  - platform: modbus_controller
    id: ${rgb_id}_rly1_off
    modbus_controller_id: ${rgb_id}
    name: "${rgb_prefix} Relay1 OFF (Pulse)"
    address: 210
    register_type: coil
    on_turn_on:
      - delay: 200ms
      - switch.turn_off: ${rgb_id}_rly1_off

  # --- DI enable/disable pulses ---
  - platform: modbus_controller
    id: ${rgb_id}_di1_enable
    modbus_controller_id: ${rgb_id}
    name: "${rgb_prefix} DI1 Enable (Pulse)"
    address: 300
    register_type: coil
    on_turn_on:
      - delay: 200ms
      - switch.turn_off: ${rgb_id}_di1_enable

  - platform: modbus_controller
    id: ${rgb_id}_di2_enable
    modbus_controller_id: ${rgb_id}
    name: "${rgb_prefix} DI2 Enable (Pulse)"
    address: 301
    register_type: coil
    on_turn_on:
      - delay: 200ms
      - switch.turn_off: ${rgb_id}_di2_enable

  - platform: modbus_controller
    id: ${rgb_id}_di1_disable
    modbus_controller_id: ${rgb_id}
    name: "${rgb_prefix} DI1 Disable (Pulse)"
    address: 320
    register_type: coil
    on_turn_on:
      - delay: 200ms
      - switch.turn_off: ${rgb_id}_di1_disable

  - platform: modbus_controller
    id: ${rgb_id}_di2_disable
    modbus_controller_id: ${rgb_id}
    name: "${rgb_prefix} DI2 Disable (Pulse)"
    address: 321
    register_type: coil
    on_turn_on:
      - delay: 200ms
      - switch.turn_off: ${rgb_id}_di2_disable

# ===================== Numbers (FC03/06/16 Holding) =====================
# PWM level sliders: 0..255 for R,G,B,WW,CW at 400..404
number:
  - platform: modbus_controller
    modbus_controller_id: ${rgb_id}
    name: "${rgb_prefix} R Level"
    address: 400
    register_type: holding
    value_type: U_WORD
    min_value: 0
    max_value: 255
    step: 1
    mode: slider

  - platform: modbus_controller
    modbus_controller_id: ${rgb_id}
    name: "${rgb_prefix} G Level"
    address: 401
    register_type: holding
    value_type: U_WORD
    min_value: 0
    max_value: 255
    step: 1
    mode: slider

  - platform: modbus_controller
    modbus_controller_id: ${rgb_id}
    name: "${rgb_prefix} B Level"
    address: 402
    register_type: holding
    value_type: U_WORD
    min_value: 0
    max_value: 255
    step: 1
    mode: slider

  - platform: modbus_controller
    modbus_controller_id: ${rgb_id}
    name: "${rgb_prefix} WW Level"
    address: 403
    register_type: holding
    value_type: U_WORD
    min_value: 0
    max_value: 255
    step: 1
    mode: slider

  - platform: modbus_controller
    modbus_controller_id: ${rgb_id}
    name: "${rgb_prefix} CW Level"
    address: 404
    register_type: holding
    value_type: U_WORD
    min_value: 0
    max_value: 255
    step: 1
    mode: slider

  # --- Optional: Modbus address / baud (take effect immediately on device) ---
  - platform: modbus_controller
    modbus_controller_id: ${rgb_id}
    name: "${rgb_prefix} MB Address"
    address: 480
    register_type: holding
    value_type: U_WORD
    min_value: 1
    max_value: 247
    step: 1

  - platform: modbus_controller
    modbus_controller_id: ${rgb_id}
    name: "${rgb_prefix} MB Baud"
    address: 481
    register_type: holding
    value_type: U_WORD
    min_value: 9600
    max_value: 115200
    step: 1
    # TIP: use standard values (9600/19200/38400/57600/115200)

# ===================== Convenience: One-shot "All Off" button =====================
button:
  - platform: template
    name: "${rgb_prefix} All Channels OFF"
    on_press:
      - modbus_controller.write_register:
          modbus_controller_id: ${rgb_id}
          address: 400
          value: 0
      - modbus_controller.write_register:
          modbus_controller_id: ${rgb_id}
          address: 401
          value: 0
      - modbus_controller.write_register:
          modbus_controller_id: ${rgb_id}
          address: 402
          value: 0
      - modbus_controller.write_register:
          modbus_controller_id: ${rgb_id}
          address: 403
          value: 0
      - modbus_controller.write_register:
          modbus_controller_id: ${rgb_id}
          address: 404
          value: 0

# ===================== OPTIONAL: Single "Light" control =====================
# This template light writes the five holding registers (400..404)
# based on RGB and CWWW values picked in Home Assistant.
# Notes:
# - Brightness and channel values are scaled to 0..255
# - mireds range is typical; adjust to your LEDs
light:
  - platform: template
    id: ${rgb_id}_light
    name: "${rgb_prefix} Light"
    default_transition_length: 150ms
    restore_state: false
    # RGB + CWWW (two white channels)
    color_mode: rgb_cwww
    min_mireds: 153
    max_mireds: 500
    on_state:
      - lambda: |-
          // Read current light state as RGB + CWWW (0.0..1.0)
          auto v = id(${rgb_id}_light).current_values;
          float br = v.get_brightness();  // 0..1
          uint16_t r  = (uint16_t) roundf(v.get_red()   * br * 255.0f);
          uint16_t g  = (uint16_t) roundf(v.get_green() * br * 255.0f);
          uint16_t b  = (uint16_t) roundf(v.get_blue()  * br * 255.0f);
          // Split whites by color temperature ratio (0..1: cw weight)
          float cw_ratio = v.get_cw();   // cool-white portion 0..1
          float ww_ratio = v.get_ww();   // warm-white portion 0..1
          uint16_t ww = (uint16_t) roundf(ww_ratio * br * 255.0f);
          uint16_t cw = (uint16_t) roundf(cw_ratio * br * 255.0f);

          // Write to holding regs 400..404
          id(${rgb_id}).write_single_register(400, r);
          id(${rgb_id}).write_single_register(401, g);
          id(${rgb_id}).write_single_register(402, b);
          id(${rgb_id}).write_single_register(403, ww);
          id(${rgb_id}).write_single_register(404, cw);

    # Switch OFF writes zeros
    on_turn_off:
      - lambda: |-
          id(${rgb_id}).write_single_register(400, 0);
          id(${rgb_id}).write_single_register(401, 0);
          id(${rgb_id}).write_single_register(402, 0);
          id(${rgb_id}).write_single_register(403, 0);
          id(${rgb_id}).write_single_register(404, 0);
